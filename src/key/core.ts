import {
  base58btc,
  base64url,
  format,
  ImplementationError,
  ImplementationErrorCode,
  type JWK,
  type JWKEC,
  type KeypairOptions,
  type VerificationMethodJwk,
  type VerificationMethodMultibase,
} from "@herculas/vc-data-integrity"

import { Ed25519Keypair } from "./keypair.ts"

import * as PREFIX_CONSTANT from "../constant/prefix.ts"
import * as SUITE_CONSTANT from "../constant/suite.ts"

/**
 * Generate a Ed25519 keypair using the Web Crypto API.
 *
 * @returns {Promise<CryptoKeyPair>} Resolve to an Ed25519 keypair.
 */
export async function generateRawKeypair(): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(SUITE_CONSTANT.ALGORITHM, true, ["sign", "verify"]) as CryptoKeyPair
}

/**
 * Calculate the key material from a CryptoKey instance. The flag determines if the key is private or public. It should
 * be noted that the key material generated by this function of both private key and public key are 32-octet arrays,
 * where the DER-encoded prefixes are removed.
 *
 * @param {CryptoKey} key A CryptoKey instance.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<Uint8Array>} Resolve to the key material.
 */
export async function keyToMaterial(key: CryptoKey, flag: KeypairOptions.Flag): Promise<Uint8Array> {
  const keyFormat = flag === "private" ? SUITE_CONSTANT.PRIVATE_KEY_FORMAT : SUITE_CONSTANT.PUBLIC_KEY_FORMAT
  const expectedDerPrefix = flag === "private" ? PREFIX_CONSTANT.PRIVATE_KEY_DER : PREFIX_CONSTANT.PUBLIC_KEY_DER

  const exportedKey = await crypto.subtle.exportKey(keyFormat, key)
  const derPrefix = new Uint8Array(exportedKey.slice(0, expectedDerPrefix.length))

  if (!derPrefix.every((value, index) => value === expectedDerPrefix[index])) {
    throw new ImplementationError(
      ImplementationErrorCode.ENCODING_ERROR,
      "keypair/core#keyToMaterial",
      `Expected the buffer to be a Ed25519 ${flag} key!`,
    )
  }

  return new Uint8Array(exportedKey.slice(expectedDerPrefix.length))
}

/**
 * Recover a Ed25519 private or public key from the provided key material.
 *
 * @param {Uint8Array} material The 32-octet public or private key material in Uint8Array format.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to the recovered Ed25519 key in `CryptoKey` format.
 */
export async function materialToKey(material: Uint8Array, flag: KeypairOptions.Flag): Promise<CryptoKey> {
  const keyFormat = flag === "private" ? SUITE_CONSTANT.PRIVATE_KEY_FORMAT : SUITE_CONSTANT.PUBLIC_KEY_FORMAT
  const derPrefix = flag === "private" ? PREFIX_CONSTANT.PRIVATE_KEY_DER : PREFIX_CONSTANT.PUBLIC_KEY_DER

  const buffer = format.concatenate(derPrefix, material)

  return await crypto.subtle.importKey(
    keyFormat,
    buffer,
    SUITE_CONSTANT.ALGORITHM,
    true,
    flag === "private" ? ["sign"] : ["verify"],
  )
}

/**
 * Encode a key material into a multibase-encoded string.
 *
 * @param {Uint8Array} material The key material in Uint8Array format.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {string} The multibase-encoded key string.
 */
export function materialToMultibase(material: Uint8Array, flag: KeypairOptions.Flag): string {
  const multibasePrefix = flag === "private"
    ? PREFIX_CONSTANT.PRIVATE_KEY_MULTIBASE
    : PREFIX_CONSTANT.PUBLIC_KEY_MULTIBASE
  const expectedLength = flag === "private" ? SUITE_CONSTANT.PRIVATE_KEY_LENGTH : SUITE_CONSTANT.PUBLIC_KEY_LENGTH

  if (material.length !== expectedLength) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_LENGTH,
      "keypair/core#materialToMultibase",
      `The ${flag} key material should be a ${expectedLength}-octet array!`,
    )
  }

  const bytes = format.concatenate(multibasePrefix, material)
  return base58btc.encode(bytes)
}

/**
 * Decode a multibase encoded private or public key into a Uint8Array key material, and check the key material against
 * the prefix from the specification. It should be noted that if the key is a private key, the decoded key material is
 * a 64-octet array, where the first 32 octets denotes the private key and the last 32 octets denotes the public key.
 *
 * @param {string} multibase A multibase-encoded private or public key string.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Uint8Array} The decoded key in Uint8Array format.
 */
export function multibaseToMaterial(multibase: string, flag: KeypairOptions.Flag): Uint8Array {
  const key = base58btc.decode(multibase)
  const expectedPrefix = flag === "private"
    ? PREFIX_CONSTANT.PRIVATE_KEY_MULTIBASE
    : PREFIX_CONSTANT.PUBLIC_KEY_MULTIBASE

  if (!expectedPrefix.every((value, index) => key[index] === value)) {
    throw new ImplementationError(
      ImplementationErrorCode.DECODING_ERROR,
      "keypair/core#multibaseToMaterial",
      "The provided multibase string does not match the specified prefix!",
    )
  }

  return key.slice(expectedPrefix.length)
}

/**
 * Calculate the thumbprint of a JWK instance using SHA-256 hash algorithm.
 *
 * @param {JWK} jwk A JSON Web Key instance.
 *
 * @returns {Promise<string>} Resolve to the thumbprint of the JWK instance.
 */
export async function getJwkThumbprint(jwk: JWK): Promise<string> {
  const data = new TextEncoder().encode(JSON.stringify(jwk))
  const hash = await crypto.subtle.digest("SHA-256", data)
  return base64url.encode(new Uint8Array(hash))
}

/**
 * Convert a `CryptoKey` instance into a `JWKEC` key object. The flag determines if the key is private or public. When
 * the key is private, the `d` field is included in the JWK object.
 *
 * @param {CryptoKey} key A `CryptoKey` instance.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<JWKEC>} Resolve to an object representing a JSON Web Key.
 */
export async function keyToJwk(key: CryptoKey, flag: KeypairOptions.Flag): Promise<JWKEC> {
  const jwk = await crypto.subtle.exportKey("jwk", key)

  return {
    kty: jwk.kty || SUITE_CONSTANT.JWK_TYPE,
    use: jwk.use || SUITE_CONSTANT.JWK_USE,
    key_ops: jwk.key_ops,
    alg: jwk.alg || SUITE_CONSTANT.ALGORITHM,
    ext: jwk.ext || true,
    crv: jwk.crv || SUITE_CONSTANT.ALGORITHM,
    x: jwk.x || "",
    y: "",
    d: flag === "private" ? jwk.d! : undefined,
  }
}

/**
 * Convert a `JWKEC` key object into a `CryptoKey` instance. The flag determines if the key is private or public. When
 * the key is private, the `d` field MUST be provided in the `jwk` input.
 *
 * @param {JWKEC} jwk An object representing a JSON Web Key.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to a `CryptoKey` instance.
 */
export async function jwkToKey(jwk: JWKEC, flag: KeypairOptions.Flag): Promise<CryptoKey> {
  const keyUsage = jwk.key_ops || (flag === "private" ? ["sign"] : ["verify"])
  const secret = flag === "private" ? jwk.d : undefined

  if (flag === "private" && !secret) {
    throw new ImplementationError(
      ImplementationErrorCode.DECODING_ERROR,
      "keypair/core#jwkToKey",
      "The private key material is missing from the JWK object!",
    )
  }

  const prepare = {
    kty: jwk.kty,
    crv: jwk.crv,
    key_ops: keyUsage,
    ext: jwk.ext || true,
    x: jwk.x,
    y: "",
    d: secret,
  }

  return await crypto.subtle.importKey("jwk", prepare, SUITE_CONSTANT.ALGORITHM, true, keyUsage as KeyUsage[])
}

/**
 * Export a Ed25519 keypair instance into a verification method containing a keypair in JWK format.
 *
 * @param {Ed25519Keypair} keypair A Ed25519 keypair instance.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<VerificationMethodJwk>} Resolve to a verification method containing a keypair in JWK format.
 */
export async function keypairToJwk(
  keypair: Ed25519Keypair,
  flag: KeypairOptions.Flag,
): Promise<VerificationMethodJwk> {
  // check the controller and identifier
  if (!keypair.controller || !keypair.id) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToJwk",
      "The keypair should have a controller and an identifier!",
    )
  }

  // prepare the document for export
  const document: VerificationMethodJwk = {
    id: keypair.id!,
    type: SUITE_CONSTANT.KEYPAIR_DOCUMENT_TYPE_JWK,
    controller: keypair.controller!,
    expires: keypair.expires ? keypair.expires.toISOString() : undefined,
    revoked: keypair.revoked ? keypair.revoked.toISOString() : undefined,
  }

  // consider the following 5 cases:
  // 1. The `flag` is `private`, but the private key is missing. Throw an error.
  // 2. The `flag` is `private`, and the public key is missing. Export the private key only.
  // 3. The `flag` is `private`, and the public key is presented. Export the public key and set the `id` accordingly.
  // 4. The `flag` is `public`, but the public key is missing. Throw an error.
  // 5. The `flag` is `public`, and the public key is presented. Export the public key, and set the `id` accordingly.

  if (flag === "private") {
    if (!keypair.privateKey) {
      throw new ImplementationError(
        ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
        "keypair/core#keypairToJwk",
        "The private key is missing from the keypair!",
      )
    } else {
      document.secretKeyJwk = await keyToJwk(keypair.privateKey, "private")
    }
  }

  if (keypair.publicKey) {
    document.publicKeyJwk = await keyToJwk(keypair.publicKey, "public")
    document.id = `${keypair.controller}#${await getJwkThumbprint(document.publicKeyJwk)}`
  } else if (flag === "public") {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToJwk",
      "The public key is missing from the keypair!",
    )
  }

  return document
}

/**
 * Import a keypair from a serialized verification method containing a keypair in JWK format.
 *
 * @param {VerificationMethodJwk} verificationMethod A verification method fetched from an external source.
 * @param {Date} [expires] The expiration date of the keypair.
 * @param {Date} [revoked] The revoked date of the keypair.
 *
 * @returns {Promise<Ed25519Keypair>} Resolve to a keypair instance.
 */
export async function jwkToKeypair(
  verificationMethod: VerificationMethodJwk,
  expires?: Date,
  revoked?: Date,
): Promise<Ed25519Keypair> {
  const keypair = new Ed25519Keypair(verificationMethod.id, verificationMethod.controller, expires, revoked)

  const innerImport = async (jwk: JWK, flag: KeypairOptions.Flag) => {
    let convertedJwk: JWKEC
    try {
      convertedJwk = jwk as JWKEC
    } catch (error) {
      throw new ImplementationError(
        ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
        `keypair/core#jwkToKeypair`,
        `The ${flag} key JWK is not well-formed: ${error}`,
      )
    }
    return await jwkToKey(convertedJwk, flag)
  }

  // import the private key if it is presented
  if (verificationMethod.secretKeyJwk) {
    keypair.privateKey = await innerImport(verificationMethod.secretKeyJwk, "private")
  }

  // import the public key if it is presented
  if (verificationMethod.publicKeyJwk) {
    keypair.publicKey = await innerImport(verificationMethod.publicKeyJwk, "public")
  }

  // both public and private key JWKs are missing
  if (!verificationMethod.secretKeyJwk && !verificationMethod.publicKeyJwk) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#jwkToKeypair",
      "Both public and private key JWKs are missing from the verification method!",
    )
  }

  return keypair
}

/**
 * Export a keypair instance into a verification method containing a keypair in multibase format.
 *
 * @param {Ed25519Keypair} keypair A Ed25519 keypair instance.
 * @param {KeypairOptions.Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<VerificationMethodMultibase>} Resolve to a verification method containing a multibase document.
 */
export async function keypairToMultibase(
  keypair: Ed25519Keypair,
  flag: KeypairOptions.Flag,
): Promise<VerificationMethodMultibase> {
  // check the controller and identifier
  if (!keypair.controller || !keypair.id) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToMultibase",
      "The keypair should have a controller and an identifier!",
    )
  }

  // prepare the document for export
  const document: VerificationMethodMultibase = {
    id: keypair.id!,
    type: SUITE_CONSTANT.KEYPAIR_DOCUMENT_TYPE_MULTI,
    controller: keypair.controller!,
    expires: keypair.expires ? keypair.expires.toISOString() : undefined,
    revoked: keypair.revoked ? keypair.revoked.toISOString() : undefined,
  }

  // consider the following 5 cases:
  // 1. The `flag` is `private`, but the private key is missing. Throw an error.
  // 2. The `flag` is `private`, and the public key is missing. Export the private key only.
  // 3. The `flag` is `private`, and the public key is presented. Export the public key and set the `id` accordingly.
  // 4. The `flag` is `public`, but the public key is missing. Throw an error.
  // 5. The `flag` is `public`, and the public key is presented. Export the public key, and set the `id` accordingly.

  if (flag === "private") {
    if (!keypair.privateKey) {
      throw new ImplementationError(
        ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
        "keypair/core#keypairToMultibase",
        "The private key is missing from the keypair!",
      )
    } else {
      const material = await keyToMaterial(keypair.privateKey, "private")
      document.secretKeyMultibase = materialToMultibase(material, "private")
    }
  }

  if (keypair.publicKey) {
    const material = await keyToMaterial(keypair.publicKey, "public")
    document.publicKeyMultibase = materialToMultibase(material, "public")
  } else if (flag === "public") {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToMultibase",
      "The public key is missing from the keypair!",
    )
  }

  return document
}

/**
 * Import a keypair from a serialized verification method containing a keypair in multibase format.
 *
 * @param {VerificationMethodMultibase} verificationMethod A verification method fetched from an external source.
 * @param {Date} [revoked] The revoked date of the keypair.
 * @param {Date} [revoked] The revoked date of the keypair.
 *
 * @returns {Promise<Ed25519Keypair>} Resolve to a keypair instance.
 */
export async function multibaseToKeypair(
  verificationMethod: VerificationMethodMultibase,
  expires?: Date,
  revoked?: Date,
): Promise<Ed25519Keypair> {
  const keypair = new Ed25519Keypair(verificationMethod.id, verificationMethod.controller, expires, revoked)

  // import the private key if it is presented
  if (verificationMethod.secretKeyMultibase) {
    const material = multibaseToMaterial(verificationMethod.secretKeyMultibase, "private")
    keypair.privateKey = await materialToKey(material, "private")
  }

  // import the public key if it is presented
  if (verificationMethod.publicKeyMultibase) {
    const material = multibaseToMaterial(verificationMethod.publicKeyMultibase, "public")
    keypair.publicKey = await materialToKey(material, "public")
  }

  // both public and private key materials are missing
  if (!verificationMethod.secretKeyMultibase && !verificationMethod.publicKeyMultibase) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#multibaseToKeypair",
      "Both public and private key materials are missing from the verification method!",
    )
  }

  return keypair
}
