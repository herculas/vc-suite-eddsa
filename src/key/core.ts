import {
  type Flag,
  format,
  ImplementationError,
  ImplementationErrorCode,
  type JWK,
  type JWKEC,
  multi,
  type VerificationMethodJwk,
  type VerificationMethodMultibase,
} from "@herculas/vc-data-integrity"

import { Ed25519Keypair } from "./keypair.ts"

import * as PREFIX_CONSTANT from "../constant/prefix.ts"
import * as SUITE_CONSTANT from "../constant/suite.ts"

/**
 * Generate an Ed25519 keypair using the Web Crypto API.
 *
 * @returns {Promise<CryptoKeyPair>} Resolve to an Ed25519 keypair.
 */
export async function generateRawKeypair(): Promise<CryptoKeyPair> {
  return await crypto.subtle.generateKey(SUITE_CONSTANT.ALGORITHM, true, ["sign", "verify"]) as CryptoKeyPair
}

/**
 * Calculate the thumbprint of a JWK instance using the SHA-256 hash algorithm.
 *
 * @param {JWK} jwk A JSON Web Key.
 *
 * @returns {Promise<string>} Resolve to the thumbprint of the `JWK` instance.
 */
export async function getJwkThumbprint(jwk: JWK): Promise<string> {
  const data = new TextEncoder().encode(JSON.stringify(jwk))
  const hash = await crypto.subtle.digest("SHA-256", data)
  return multi.base64url.encode(new Uint8Array(hash))
}

/**
 * Export a `CryptoKey` instance to a verification method document. The key is stored in the exported document in either
 * `JsonWebKey` or `Multikey` format, specified by the `type` field in the document. The `JsonWebKey` or `Multikey` 
 * generated from the above process will ultimately be wrapped into a verification method document, along with other 
 * metadata associated with that key, such as the controller, identifier, and expiration date.
 *
 * The flowchart below briefly illustrates this export process:
 *
 *        keyToMaterial                  materialToMultibase                        keypairToMultibase
 *     ┌──────────────────> Key Material ─────────────────────> Multibase Key ──────────────────────────────┐
 *     │                  (32-octet array)                  (base-58-btc string)                            │
 * CryptoKey                                                                                       Verification Method
 *     │                       keyToJwk                                               keypairToJwk          │
 *     └─────────────────────────────────────────────────────> JSON Web Key ────────────────────────────────┘
 *                                                               (JWKEC)
 */

/**
 * Calculate the key material from a `CryptoKey` instance. The flag determines if the key is private or public. It
 * should be noted that the key material generated by this function of both private key and public key are 32-octet
 * arrays, where the DER prefixes are removed.
 *
 * @param {CryptoKey} key A `CryptoKey` instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<Uint8Array>} Resolve to the key material.
 */
export async function keyToMaterial(key: CryptoKey, flag: Flag): Promise<Uint8Array> {
  const keyFormat = SUITE_CONSTANT.KEY_FORMAT.get(flag)
  const materialLength = SUITE_CONSTANT.KEY_MATERIAL_LENGTH.get(flag)
  const derPrefixHex = PREFIX_CONSTANT.DER.get(flag)

  if (!keyFormat || !materialLength || !derPrefixHex) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keyToMaterial",
      `This suite does not support ${flag} key!`,
    )
  }

  const derPrefix = format.hexToBytes(derPrefixHex)
  const derMaterial = await crypto.subtle.exportKey(keyFormat, key)
  const realPrefix = new Uint8Array(derMaterial.slice(0, derPrefix.length))

  if (!realPrefix.every((value, index) => value === derPrefix[index])) {
    throw new ImplementationError(
      ImplementationErrorCode.ENCODING_ERROR,
      "keypair/core#keyToMaterial",
      `The ${flag} key material does not have the expected DER prefix!`,
    )
  }

  const material = new Uint8Array(derMaterial.slice(derPrefix.length))
  if (material.length !== materialLength) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_LENGTH,
      "keypair/core#keyToMaterial",
      `The ${flag} key material should be a ${materialLength}-octet array!`,
    )
  }
  return material
}

/**
 * Encode a key material into a multibase string.
 *
 * @param {Uint8Array} material The key material in `Uint8Array` format.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {string} The multibase string representing the key material.
 */
export function materialToMultibase(material: Uint8Array, flag: Flag): string {
  const multibasePrefixHex = PREFIX_CONSTANT.MULTIBASE.get(flag)
  const materialLength = SUITE_CONSTANT.KEY_MATERIAL_LENGTH.get(flag)

  if (!multibasePrefixHex || !materialLength) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#materialToMultibase",
      `This suite does not support ${flag} key!`,
    )
  }

  if (material.length !== materialLength) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_LENGTH,
      "keypair/core#materialToMultibase",
      `The ${flag} key material should be a ${materialLength}-octet array!`,
    )
  }

  const multibasePrefix = format.hexToBytes(multibasePrefixHex)
  const multibaseMaterial = format.concatenate(multibasePrefix, material)
  return multi.base58btc.encode(multibaseMaterial)
}

/**
 * Export an Ed25519 keypair instance into a verification method containing a keypair in `Multikey` format.
 *
 * @param {Ed25519Keypair} keypair An Ed25519 keypair instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<VerificationMethodMultibase>} Resolve to a verification method document containing a `Multikey`
 * keypair.
 */
export async function keypairToMultibase(
  keypair: Ed25519Keypair,
  flag: Flag,
): Promise<VerificationMethodMultibase> {
  // check the controller and identifier
  if (!keypair.controller || !keypair.id) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToMultibase",
      "The keypair should have a controller and an identifier!",
    )
  }

  // prepare the document for export
  const document: VerificationMethodMultibase = {
    id: keypair.id!,
    type: SUITE_CONSTANT.KEYPAIR_DOCUMENT_TYPE_MULTI,
    controller: keypair.controller!,
    expires: keypair.expires ? format.toW3CTimestamp(keypair.expires) : undefined,
    revoked: keypair.revoked ? format.toW3CTimestamp(keypair.revoked) : undefined,
  }

  // consider the following 5 cases:
  //
  // 1. The `flag` is `private`, but the private key is missing. Throw an error.
  // 2. The `flag` is `private`, and the public key is missing. Export the private key only.
  // 3. The `flag` is `private`, and the public key is presented. Export the public key and set the `id` accordingly.
  // 4. The `flag` is `public`, but the public key is missing. Throw an error.
  // 5. The `flag` is `public`, and the public key is presented. Export the public key, and set the `id` accordingly.

  if (flag === "private") {
    if (!keypair.privateKey) {
      throw new ImplementationError(
        ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
        "keypair/core#keypairToMultibase",
        "The private key is missing from the keypair!",
      )
    } else {
      const material = await keyToMaterial(keypair.privateKey, "private")
      document.secretKeyMultibase = materialToMultibase(material, "private")
    }
  }

  if (keypair.publicKey) {
    const material = await keyToMaterial(keypair.publicKey, "public")
    document.publicKeyMultibase = materialToMultibase(material, "public")
  } else if (flag === "public") {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToMultibase",
      "The public key is missing from the keypair!",
    )
  }

  return document
}

/**
 * Convert a `CryptoKey` instance into a `JWKEC` key object. The flag determines if the key is private or public. When
 * the key is private, the `d` field is included in the `JWKEC` instance.
 *
 * @param {CryptoKey} key A `CryptoKey` instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<JWKEC>} Resolve to a `JWKEC` object representing a JSON Web Key.
 */
export async function keyToJwk(key: CryptoKey, flag: Flag): Promise<JWKEC> {
  const jwk = await crypto.subtle.exportKey("jwk", key)

  return {
    kty: jwk.kty || SUITE_CONSTANT.JWK_TYPE,
    use: jwk.use || SUITE_CONSTANT.JWK_USE,
    key_ops: jwk.key_ops,
    alg: jwk.alg || SUITE_CONSTANT.ALGORITHM,
    ext: jwk.ext || true,
    crv: jwk.crv || SUITE_CONSTANT.ALGORITHM,
    x: jwk.x || "",
    y: "",
    d: flag === "private" ? jwk.d! : undefined,
  }
}

/**
 * Export an Ed25519 keypair instance into a verification method containing a keypair in `JWK` format.
 *
 * @param {Ed25519Keypair} keypair An Ed25519 keypair instance.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<VerificationMethodJwk>} Resolve to a verification method document containing a JSON Web Key.
 */
export async function keypairToJwk(
  keypair: Ed25519Keypair,
  flag: Flag,
): Promise<VerificationMethodJwk> {
  // check the controller and identifier
  if (!keypair.controller || !keypair.id) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToJwk",
      "The keypair should have a controller and an identifier!",
    )
  }

  // prepare the document for export
  const document: VerificationMethodJwk = {
    id: keypair.id!,
    type: SUITE_CONSTANT.KEYPAIR_DOCUMENT_TYPE_JWK,
    controller: keypair.controller!,
    expires: keypair.expires ? format.toW3CTimestamp(keypair.expires) : undefined,
    revoked: keypair.revoked ? format.toW3CTimestamp(keypair.revoked) : undefined,
  }

  // consider the following 5 cases:
  //
  // 1. The `flag` is `private`, but the private key is missing. Throw an error.
  // 2. The `flag` is `private`, and the public key is missing. Export the private key only.
  // 3. The `flag` is `private`, and the public key is presented. Export the public key and set the `id` accordingly.
  // 4. The `flag` is `public`, but the public key is missing. Throw an error.
  // 5. The `flag` is `public`, and the public key is presented. Export the public key, and set the `id` accordingly.

  if (flag === "private") {
    if (!keypair.privateKey) {
      throw new ImplementationError(
        ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
        "keypair/core#keypairToJwk",
        "The private key is missing from the keypair!",
      )
    } else {
      document.secretKeyJwk = await keyToJwk(keypair.privateKey, "private")
    }
  }

  if (keypair.publicKey) {
    document.publicKeyJwk = await keyToJwk(keypair.publicKey, "public")
    document.id = `${keypair.controller}#${await getJwkThumbprint(document.publicKeyJwk)}`
  } else if (flag === "public") {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#keypairToJwk",
      "The public key is missing from the keypair!",
    )
  }

  return document
}

/**
 * Import a verification method document into a `CryptoKey` instance. The key is stored in the verification method
 * document in either `JsonWebKey` or `Multikey` format, as specified by the type field in the document.
 *
 * The flowchart below briefly illustrates this export process:
 *
 *                       multibaseToKeypair                  multibaseToMaterial                 materialToKey
 *  Verification Method ────────────────────> Multibase Key ────────────────────> Key Material ─────────────────┐
 *   (Multibase within)                   (base-58-btc string)                  (32-octet array)                │
 *                                                                                                          CryptoKey
 *                         jwkToKeypair                                           jwkToKey                      │
 *  Verification Method ──────────────────> JSON Web Key ───────────────────────────────────────────────────────┘
 *      (JWK within)                          (JWKEC)
 */

/**
 * Import an Ed25519 keypair from a verification method document containing a keypair in `Multikey` format.
 *
 * @param {VerificationMethodMultibase} verificationMethod A verification method fetched from an external source.
 * @param {Date} [revoked] The expiration date of the keypair.
 * @param {Date} [revoked] The revoked date of the keypair.
 *
 * @returns {Promise<Ed25519Keypair>} Resolve to an Ed25519 keypair instance.
 */
export async function multibaseToKeypair(
  verificationMethod: VerificationMethodMultibase,
  expires?: Date,
  revoked?: Date,
): Promise<Ed25519Keypair> {
  const keypair = new Ed25519Keypair(verificationMethod.id, verificationMethod.controller, expires, revoked)

  // import the private key if it is presented
  if (verificationMethod.secretKeyMultibase) {
    const material = multibaseToMaterial(verificationMethod.secretKeyMultibase, "private")
    keypair.privateKey = await materialToKey(material, "private")
  }

  // import the public key if it is presented
  if (verificationMethod.publicKeyMultibase) {
    const material = multibaseToMaterial(verificationMethod.publicKeyMultibase, "public")
    keypair.publicKey = await materialToKey(material, "public")
  }

  // both public and private key materials are missing
  if (!verificationMethod.secretKeyMultibase && !verificationMethod.publicKeyMultibase) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#multibaseToKeypair",
      "Both public and private key materials are missing from the verification method!",
    )
  }

  return keypair
}

/**
 * Decode a multibase encoded private or public key into an `Uint8Array` key material, and check the key material
 * against the multibase prefix according to the specification.
 *
 * @param {string} multibase A multibase private or public key string.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Uint8Array} The decoded key in `Uint8Array` format.
 */
export function multibaseToMaterial(multibase: string, flag: Flag): Uint8Array {
  const multibaseMaterial = multi.base58btc.decode(multibase)
  const multibasePrefixHex = PREFIX_CONSTANT.MULTIBASE.get(flag)
  const materialLength = SUITE_CONSTANT.KEY_MATERIAL_LENGTH.get(flag)

  if (!materialLength || !multibasePrefixHex) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#multibaseToMaterial",
      `This suite does not support ${flag} key!`,
    )
  }

  const multibasePrefix = format.hexToBytes(multibasePrefixHex)
  if (!multibasePrefix.every((value, index) => multibaseMaterial[index] === value)) {
    throw new ImplementationError(
      ImplementationErrorCode.DECODING_ERROR,
      "keypair/core#multibaseToMaterial",
      `The provided ${flag} key multibase ${multibase} does not match the specified prefix!`,
    )
  }

  const material = multibaseMaterial.slice(multibasePrefix.length)
  if (material.length !== materialLength) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_LENGTH,
      "keypair/core#multibaseToMaterial",
      `The ${flag} key material should be a ${materialLength}-octet array!`,
    )
  }
  return material
}

/**
 * Recover an Ed25519 private or public key from the provided key material.
 *
 * @param {Uint8Array} material The 32-octet public or private key material in `Uint8Array` format.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to the recovered Ed25519 key in `CryptoKey` format.
 */
export async function materialToKey(material: Uint8Array, flag: Flag): Promise<CryptoKey> {
  const keyFormat = SUITE_CONSTANT.KEY_FORMAT.get(flag)
  const materialLength = SUITE_CONSTANT.KEY_MATERIAL_LENGTH.get(flag)
  const derPrefixHex = PREFIX_CONSTANT.DER.get(flag)

  if (!keyFormat || !materialLength || !derPrefixHex) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#materialToKey",
      `This suite does not support ${flag} key!`,
    )
  }

  if (material.length !== materialLength) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_LENGTH,
      "keypair/core#materialToKey",
      `The ${flag} key material should be a ${materialLength}-octet array!`,
    )
  }

  const derPrefix = format.hexToBytes(derPrefixHex)
  const derMaterial = format.concatenate(derPrefix, material)
  const usage: KeyUsage[] = flag === "private" ? ["sign"] : ["verify"]
  return await crypto.subtle.importKey(keyFormat, derMaterial, SUITE_CONSTANT.ALGORITHM, true, usage)
}

/**
 * Import an Ed25519 keypair from a verification method document containing a keypair in JWK format.
 *
 * @param {VerificationMethodJwk} verificationMethod A verification method fetched from an external source.
 * @param {Date} [expires] The expiration date of the keypair.
 * @param {Date} [revoked] The revoked date of the keypair.
 *
 * @returns {Promise<Ed25519Keypair>} Resolve to an Ed25519 keypair instance.
 */
export async function jwkToKeypair(
  verificationMethod: VerificationMethodJwk,
  expires?: Date,
  revoked?: Date,
): Promise<Ed25519Keypair> {
  const keypair = new Ed25519Keypair(verificationMethod.id, verificationMethod.controller, expires, revoked)

  const innerImport = async (jwk: JWK, flag: Flag) => {
    let convertedJwk: JWKEC
    try {
      convertedJwk = jwk as JWKEC
    } catch (error) {
      throw new ImplementationError(
        ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
        `keypair/core#jwkToKeypair`,
        `The JWK object of the ${flag} key is not well-formed: ${error}`,
      )
    }
    return await jwkToKey(convertedJwk, flag)
  }

  // import the private key if it is presented
  if (verificationMethod.secretKeyJwk) {
    keypair.privateKey = await innerImport(verificationMethod.secretKeyJwk, "private")
  }

  // import the public key if it is presented
  if (verificationMethod.publicKeyJwk) {
    keypair.publicKey = await innerImport(verificationMethod.publicKeyJwk, "public")
  }

  // both public and private key JWKs are missing
  if (!verificationMethod.secretKeyJwk && !verificationMethod.publicKeyJwk) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#jwkToKeypair",
      "Both public and private key JWKs are missing from the verification method!",
    )
  }

  return keypair
}

/**
 * Convert a `JWKEC` key object into a `CryptoKey` instance. The flag determines if the key is private or public. When
 * the key is private, the `d` field MUST be provided in the `jwk` input.
 *
 * @param {JWKEC} jwk An `JWKEC` object representing a JSON Web Key.
 * @param {Flag} flag The flag to determine if the key is private or public.
 *
 * @returns {Promise<CryptoKey>} Resolve to a `CryptoKey` instance.
 */
export async function jwkToKey(jwk: JWKEC, flag: Flag): Promise<CryptoKey> {
  const defaultUsage = flag === "private" ? ["sign"] : ["verify"]
  const keyUsage = (jwk.key_ops || defaultUsage) as KeyUsage[]
  const secret = flag === "private" ? jwk.d : undefined

  if (flag === "private" && !secret) {
    throw new ImplementationError(
      ImplementationErrorCode.DECODING_ERROR,
      "keypair/core#jwkToKey",
      "The private key material is missing from the JWK object!",
    )
  }

  if (jwk.kty !== SUITE_CONSTANT.JWK_TYPE) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#jwkToKey",
      `The 'kty' field ${jwk.kty} of the JWK object is not supported!`,
    )
  }

  if (jwk.crv !== SUITE_CONSTANT.ALGORITHM) {
    throw new ImplementationError(
      ImplementationErrorCode.INVALID_KEYPAIR_CONTENT,
      "keypair/core#jwkToKey",
      `The 'crv' field ${jwk.crv} of the JWK object is not supported!`,
    )
  }

  const prepare = {
    kty: jwk.kty,
    crv: jwk.crv,
    key_ops: keyUsage,
    ext: jwk.ext || true,
    x: jwk.x,
    y: "",
    d: secret,
  }

  return await crypto.subtle.importKey("jwk", prepare, SUITE_CONSTANT.ALGORITHM, true, keyUsage)
}
